---
? !!python/name:helpers.logging_helper.LoggingHelper
:
  init:
    LOGFILE: PDBBRK_LOGFILE
    LEVEL: DEBUG
    HANDLER_NAME: PDB BREAK (DEBUG)
  filters:
    input:
      frame:
        type: frame
        exp: >
          dict(file=v_.f_code.co_filename, line=v_.f_lineno, name=v_.f_code.co_name)
      bl:
        type: BreakLoc
        exp: >
          non_none(attr.asdict(v_))
      bls:
        types: [list, deque]
        cond: all(isinstance(i, BreakLoc) for i in v_)
        exp: >
          [non_none(attr.asdict(i)) for i in v_]
    output:
      tmpdir:
        pat: !!python/object/new:re.compile ["/tmp/pytest-of[^/]+/pytest-\\d+"]
        new: "$T"
        method: sub
  exec: |
    def non_none(d):
        return {k: v for k, v in d.items() if v is not None}

pytest_internalerror:
  1:
    args:
      - excinfo.type
      - excinfo.value

pytest_runtestloop:
  1:
    args:
      - self.wanted
      - locs
  2:
    kwargs:
      "wanted.file": >
        "'' -> {}".format(self.wanted.file)
  3:
    args:
      - self.targets
      - self.target

runcall_until:
  with_enter_pdb:
    assertions:
      - self.last_pdb
  pre_capfix:
    kwargs:
      testargs: testargs
  cap_top:
    kwargs:
      prevstdout: sys.stdout
  cap_bot:
    kwargs:
      stdout: type(sys.stdout)
      cap_method: capman._method
  post_capfix:
    args:
      - inst.botframe

pytest_pyfunc_call:
  1:
    assertions:
      - self.last_pdb is None
      - not pyfuncitem._isyieldedfunction()
    args:
      - pyfuncitem.name
      - pyfuncitem.location
      - pyfuncitem.funcargs
      - self.target
    kwargs:
      "loc equals target": BreakLoc.from_pytest_item(pyfuncitem) == self.target
  2:
    args:
      - self.target
      - self.targets

find_breakable_line:
  1:
    args:
      - lineno
      - line

add_completion:
  1:
    assertions:
      - >
        pytestPDB._pdb_cls is sys.modules["_pytest.debugging"].pdb.Pdb
      - >
        "complete" not in pytestPDB._pdb_cls.__dict__
