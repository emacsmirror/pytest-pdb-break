---
? !!python/name:knotty_logger.LoggingHelper
:
  init:
    LOGFILE: PDBBRK_LOGFILE
    LEVEL: DEBUG
    HANDLER_NAME: PDB BREAK (DEBUG)
  filters:
    input:
      frame:
        type: frame
        exp: >
          dict(file=v_.f_code.co_filename, line=v_.f_lineno, name=v_.f_code.co_name)
      bl:
        type: BreakLocation
        exp: >
          non_none(attr.asdict(v_))
      tinfo:
        type: TargetInfo
        exp: >
          non_none(attr.asdict(v_))
      bls:
        type: list
        cond: all(isinstance(i, BreakLocation) for i in v_)
        exp: >
          [non_none(attr.asdict(i)) for i in v_]
      syscap:
        type: SysCapture
        exp: vars(v_)
      textio:
        type: TextIOWrapper
        exp: >
          dict(type=type(v_).__name__, name=v_.name,
               mode=v_.mode, addr=hex(id(v_)))
      capio:
        type: CaptureIO
        exp: >
          dict(type=type(v_).__name__, addr=hex(id(v_)))
      encoded_file:
        type: EncodedFile
        exp: >
          dict(type=type(v_).__name__, buffer=v_.name)
    output:
      tmpdir:
        pat: !!python/object/new:re.compile ["/tmp/pytest-of[^/]+/pytest-\\d+"]
        new: "$T"
        method: sub
  exec: |
    def non_none(d):
        return {k: v for k, v in d.items() if v is not None}

pytest_internalerror:
  1:
    args:
      - excinfo.type
      - excinfo.value

PdbBreak.__init__:
  bottom:
    args:
      - self.wanted

_ensure_wanted:
  rewrite:
    args:
      - self.wanted

find_targets:
  top:
    args:
      - func_items
  fortified:
    args:
      - fortified
  targets:
    args:
      - self.targets
  elsewhere:
    args:
      - self.elsewhere

_handle_capture:
  cap_top:
    kwargs:
      "global_cap": >
        {k: vars(v) if hasattr(v, '__dict__') else v
         for k, v in vars(capman._global_capturing).items()}
      "sys.stdout (before)": sys.stdout
  cap_bot:
    args:
      - capman._method
    kwargs:
      "capfix": capfix and vars(capfix._capture)
      "sys.stdout (after)": type(sys.stdout)

runcall_until:
  with_enter_pdb:
    assertions:
      - self.last_pdb
  pre_capfix:
    args:
      - func
      - testargs
  post_capfix:
    args:
      - inst.botframe

pytest_pyfunc_call:
  1:
    assertions:
      - not hasattr(pyfuncitem, "_isyieldedfunction")
    args:
      - pyfuncitem.name
      - pyfuncitem.location
      - pyfuncitem.funcargs
    kwargs:
      "is target?": pyfuncitem is self.targets[0] if self.targets else False
  2:
    args:
      - self.targets

find_breakable_line:
  1:
    args:
      - lineno
      - line

add_completion:
  1:
    assertions:
      - not hasattr(pytestPDB, "_pdb_cls")
